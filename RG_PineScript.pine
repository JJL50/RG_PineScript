//@version=6
indicator("Pine Script 고급 메타 검증 도구 v6", overlay=true, max_labels_count=500)

// ============================================
// 파인 스크립트 종합 오류 검사 및 수정 가이드
// ============================================

// 입력 설정
showErrorGuide = input.bool(true, "오류 가이드 표시", group="설정")
showCalculationErrors = input.bool(true, "계산 오류 표시", group="설정")
showAdvancedErrors = input.bool(true, "고급 오류 표시", group="설정")
errorDetailLevel = input.int(2, "상세 레벨", minval=1, maxval=3, group="설정")

// ============================================
// PART 1: 기본 구문 오류
// ============================================

// 1.1 버전 선언 오류
// 오류: //@version=6 누락 또는 잘못된 위치
// 수정: 반드시 스크립트 첫 줄에 위치

// 1.2 변수 선언 오류
var float correctVar = 0  // 올바른: var 사용
varip float realtimeVar = 0  // 실시간 전용 변수

// 오류: 변수명에 예약어 사용 금지
// 잘못된 예: close = 100, open = 50, high = 200
// 올바른 예:
float myClose = 100
float myOpen = 50
float myHigh = 200

// ============================================
// PART 2: IF 표현식 계산 오류 (중요!)
// ============================================

// 2.1 IF 표현식 타입 일관성 오류
// 오류: if 모든 분기에서 같은 타입 반환 필요
// 잘못된 예:
// wrongIf = if close > open
//     100.5      // float
// else
//     "text"     // string - 오류!

// 올바른 예 1: 타입 일치
correctIf1 = if close > open
    100.5  // float
else
    50.0   // float - OK

// 올바른 예 2: na 사용
correctIf2 = if close > open
    close
else
    na  // na는 모든 타입과 호환

// 2.2 IF 표현식 반환값 누락 오류
// 오류: else 분기 누락 시 암묵적으로 na 반환
incompleteIf = if close > open
    100.0
// else 없음 - 조건 false일 때 na 반환됨!

// 올바른 예: 모든 분기 명시
completeIf = if close > open
    100.0
else if close < open
    -100.0
else
    0.0

// 2.3 IF 표현식 중첩 오류
// 오류: 과도한 중첩으로 인한 가독성 저하
// 잘못된 예 (너무 복잡):
// badNested = if cond1
//     if cond2
//         if cond3
//             val1
//         else val2
//     else val3
// else val4

// 올바른 예: switch 사용
condition1 = close > open
condition2 = close > high[1]
condition3 = volume > ta.sma(volume, 20)

betterNested = switch
    condition1 and condition2 and condition3 => 3
    condition1 and condition2 => 2
    condition1 => 1
    => 0

// 2.4 IF 표현식과 var 변수 조합 오류
// 오류: var 변수를 if 표현식 결과로 직접 할당
var float accumulator = 0

// 잘못된 패턴: 초기화가 매 바마다 발생할 수 있음
// accumulator = if condition1 0.0 else accumulator + 1

// 올바른 패턴:
if condition1
    accumulator := 0.0
else
    accumulator += 1.0

// ============================================
// PART 3: 튜플(Tuple) 관련 오류
// ============================================

// 3.1 튜플 반환 함수 정의 오류
// 오류: 튜플 요소 개수/타입 불일치
// 잘못된 예:
// badTupleFunc() =>
//     if condition
//         [1, 2, 3]      // 3개
//     else
//         [1, 2]         // 2개 - 오류!

// 올바른 예: 모든 분기에서 같은 개수 반환
correctTupleFunc() =>
    if condition1
        [close, high, volume]
    else
        [open, low, volume]

[val1, val2, val3] = correctTupleFunc()

// 3.2 튜플 언패킹 오류
// 오류: 선언된 변수 개수와 튜플 크기 불일치
calcMultipleValues() =>
    sma20 = ta.sma(close, 20)
    sma50 = ta.sma(close, 50)
    crossUp = ta.crossover(sma20, sma50)
    crossDown = ta.crossunder(sma20, sma50)
    [sma20, sma50, crossUp, crossDown]

// 잘못된 예: [a, b] = calcMultipleValues()  // 4개 반환하는데 2개만 받음
// 올바른 예:
[ma20, ma50, crossU, crossD] = calcMultipleValues()

// 3.3 튜플과 request.security 조합 오류
// 오류: request.security에서 튜플 반환 시 함수 필요
// 잘못된 예:
// htfData = request.security(syminfo.tickerid, "D", [close, open])  // 오류!

// 올바른 예: 함수로 래핑
getMultipleValues() =>
    [close, open, high, low]

[htfClose, htfOpen, htfHigh, htfLow] = request.security(syminfo.tickerid, "D", getMultipleValues())

// 3.4 튜플 타입 명시 오류
// 올바른 타입 명시 방법
strictTupleFunc() =>
    float ma = ta.sma(close, 14)
    bool uptrend = close > ma
    int barCount = bar_index
    [ma, uptrend, barCount]

// 타입이 명확한 언패킹
[typedMa, typedTrend, typedCount] = strictTupleFunc()

// ============================================
// PART 4: 함수 정의 및 호출 계산 오류
// ============================================

// 4.1 함수 매개변수 타입 한정자 오류
// 오류: series/simple 혼동
// simple: 컴파일 시점 또는 입력값으로 결정되는 단순 값
// series: 각 바마다 변할 수 있는 시계열 값

// 올바른 예: 매개변수 타입 명시
calcWithSimple(simple int period) =>
    ta.sma(close, period)  // period는 상수여야 함

calcWithSeries(series float source) =>
    source * 2  // source는 각 바마다 달라질 수 있음

resultSimple = calcWithSimple(14)
resultSeries = calcWithSeries(close)

// 4.2 함수 내부 scope 오류
// 오류: 함수 내에서 선언한 변수는 외부 접근 불가
globalCounter = 0

funcWithScope() =>
    localValue = 100  // 로컬 변수
    globalCounter + localValue

scopeResult = funcWithScope()
// localValue 여기서 접근 불가!

// 4.3 함수 오버로딩 불가 오류
// 오류: Pine Script는 함수 오버로딩 미지원
// 잘못된 예: 같은 이름의 함수 여러 개 정의 불가
// myFunc(int x) => x * 2
// myFunc(float x) => x * 2.5  // 오류!

// 올바른 예: 다른 이름 사용
myFuncInt(int x) => x * 2
myFuncFloat(float x) => x * 2.5

// 4.4 함수 반환값 계산 오류
// 오류: 마지막 표현식이 반환값
calculateIndicator(simple int len) =>
    sma = ta.sma(close, len)
    ema = ta.ema(close, len)
    rsi = ta.rsi(close, len)
    // 잘못된 생각: 모든 값이 반환된다고 착각
    // 실제: 마지막 표현식인 rsi만 반환됨!
    rsi  // 명시적으로 반환값 표시 (선택사항)

onlyRsi = calculateIndicator(14)  // rsi만 받음

// 여러 값 반환하려면 튜플 사용
calculateMultiple(simple int len) =>
    sma = ta.sma(close, len)
    ema = ta.ema(close, len)
    rsi = ta.rsi(close, len)
    [sma, ema, rsi]  // 튜플로 반환

[mySma, myEma, myRsi] = calculateMultiple(14)

// ============================================
// PART 5: 연산자 우선순위 및 계산 오류
// ============================================

// 5.1 논리 연산자 우선순위 오류
// 오류: and/or 우선순위 혼동
// and가 or보다 우선순위 높음

// 잘못된 이해:
// condition = true or false and false
// 예상: (true or false) and false = false
// 실제: true or (false and false) = true

// 올바른 사용: 괄호로 명시
safeCondition1 = (close > open or close > close[1]) and volume > 0
safeCondition2 = close > open or (close > close[1] and volume > 0)

// 5.2 삼항 연산자 중첩 오류
// 오류: 중첩된 삼항 연산자 가독성 문제
// 잘못된 예 (읽기 어려움):
badTernary = close > open ? high > high[1] ? 1 : 0 : low < low[1] ? -1 : 0

// 올바른 예: 명시적 분기
goodTernary = 
 close > open ? 
     (high > high[1] ? 1 : 0) : 
     (low < low[1] ? -1 : 0)

// 더 나은 방법: if 표현식 사용
bestApproach = if close > open
    if high > high[1]
        1
    else
        0
else
    if low < low[1]
        -1
    else
        0

// 5.3 나눗셈 0 오류
// 오류: 0으로 나누기
divisor = high - low

// 잘못된 예:
// result = close / divisor  // divisor가 0이면 Infinity

// 올바른 예: 0 체크
safeDivision = divisor != 0 ? close / divisor : 0

// 더 안전한 방법:
saferDivision = na(divisor) or divisor == 0 ? na : close / divisor

// 5.4 부동소수점 비교 오류
// 오류: float 직접 비교
value1 = 0.1 + 0.2
value2 = 0.3

// 잘못된 예:
// isEqual = value1 == value2  // 부동소수점 오차로 false일 수 있음

// 올바른 예: 오차 범위 내 비교
epsilon = 0.0001
isApproximatelyEqual = math.abs(value1 - value2) < epsilon

// ============================================
// PART 6: 시계열 연산 오류
// ============================================

// 6.1 룩백 참조 오류
// 오류: 첫 바에서 과거 참조
// 잘못된 예: 첫 바에서 close[1]은 na

// 올바른 예: na 체크
prevClose = na(close[1]) ? close : close[1]
change = close - prevClose

// 6.2 시계열 함수 period 오류
// 오류: period가 현재 바 인덱스보다 큼
// 잘못된 예: bar_index가 5인데 ta.sma(close, 100) 계산

// 올바른 예: 최소 기간 확인
minPeriod = 20
validPeriod = bar_index >= minPeriod

smaValue = validPeriod ? ta.sma(close, minPeriod) : na

// 6.3 [] 연산자와 함수 결과 조합 오류
// 오류: 함수 결과에 바로 [] 적용 불가
// 잘못된 예:
// prevSma = ta.sma(close, 20)[1]  // 오류!

// 올바른 예: 변수에 할당 후 참조
currentSma = ta.sma(close, 20)
previousSma = currentSma[1]

// 6.4 시계열 길이 불일치 오류
// 오류: 서로 다른 시간대의 데이터 직접 비교
htfClose = request.security(syminfo.tickerid, "D", close)

// 잘못된 계산:
// diff = close - htfClose  // 시간대 불일치로 부정확

// 올바른 방법: 리페인팅 방지
htfCloseSafe = request.security(syminfo.tickerid, "D", close[1], barmerge.gaps_off, barmerge.lookahead_on)

// ============================================
// PART 7: 배열 계산 오류
// ============================================

// 7.1 배열 초기화 오류
// 오류: 잘못된 초기값
// 잘못된 예:
// arr = array.new_float()  // 크기 0인 배열, 접근 시 오류

// 올바른 예:
arr1 = array.new_float(10, 0.0)  // 크기 10, 초기값 0.0
arr2 = array.from(1.0, 2.0, 3.0)  // 초기값으로 생성

// 7.2 배열 범위 검사 누락 오류
var prices = array.new_float(0)
array.push(prices, close)

// 잘못된 예:
// lastPrice = array.get(prices, array.size(prices) - 1)  // 크기 0이면 오류

// 올바른 예:
lastPrice = array.size(prices) > 0 ? array.get(prices, array.size(prices) - 1) : na

// 7.3 배열 루프 계산 오류
// 오류: 루프 중 배열 크기 변경
testArray = array.new_float(0)
array.push(testArray, 1.0)
array.push(testArray, 2.0)
array.push(testArray, 3.0)

// 잘못된 예:
// for i = 0 to array.size(testArray) - 1
//     array.push(testArray, i)  // 크기가 계속 변함 - 무한 루프 위험!

// 올바른 예: 크기 미리 저장
arraySize = array.size(testArray)
for i = 0 to arraySize - 1
    value = array.get(testArray, i)
    // 계산 수행

// 7.4 배열 복사 오류
// 오류: 얕은 복사 vs 깊은 복사
original = array.from(1.0, 2.0, 3.0)

// 잘못된 예:
// shallow = original  // 참조만 복사, 같은 배열 가리킴

// 올바른 예:
deep = array.copy(original)  // 완전히 새로운 배열
array.set(deep, 0, 999.0)  // original은 영향 없음

// ============================================
// PART 8: MAP과 매트릭스 계산 오류
// ============================================

// 8.1 Map 키 타입 오류
// Map 키는 string만 가능
myMap = map.new<string, float>()

// 잘못된 예:
// map.put(myMap, 123, 45.6)  // 키가 int - 오류!

// 올바른 예:
map.put(myMap, "key1", 45.6)
map.put(myMap, str.tostring(bar_index), close)

// 8.2 Map 존재 확인 누락 오류
// 잘못된 예:
// value = map.get(myMap, "nonexistent")  // 없으면 runtime error

// 올바른 예:
key = "price"
hasKey = map.contains(myMap, key)
safeValue = hasKey ? map.get(myMap, key) : na

// 8.3 Matrix 차원 불일치 오류
// 오류: 행렬 연산 시 차원 불일치
matrix1 = matrix.new<float>(2, 3, 0)  // 2x3 행렬
matrix2 = matrix.new<float>(3, 2, 0)  // 3x2 행렬

// 잘못된 연산:
// result = matrix.mult(matrix1, matrix1)  // 2x3 * 2x3 불가능

// 올바른 연산:
validResult = matrix.mult(matrix1, matrix2)  // 2x3 * 3x2 = 2x2

// ============================================
// PART 9: 조건부 축적 계산 오류
// ============================================

// 9.1 조건부 카운터 오류
var int buyCount = 0
var int sellCount = 0

buySignal = ta.crossover(ta.rsi(close, 14), 30)
sellSignal = ta.crossunder(ta.rsi(close, 14), 70)

// 잘못된 패턴:
// if buySignal
//     buyCount = buyCount + 1  // var 변수는 := 사용

// 올바른 패턴:
if buySignal
    buyCount += 1  // 또는 buyCount := buyCount + 1

if sellSignal
    sellCount += 1

// 9.2 조건부 합계 계산 오류
var float totalProfit = 0.0
var float entryPrice = 0.0
var bool inPosition = false

// 잘못된 로직:
// if buySignal
//     inPosition = true  // var 변수는 := 필요
//     entryPrice = close

// 올바른 로직:
if buySignal and not inPosition
    inPosition := true
    entryPrice := close

if sellSignal and inPosition
    profit = close - entryPrice
    totalProfit += profit
    inPosition := false

// ============================================
// PART 10: 재귀 및 복잡한 계산 오류
// ============================================

// 10.1 재귀 불가 오류
// 오류: Pine Script는 재귀 함수 미지원
// 잘못된 예:
// factorial(int n) =>
//     n <= 1 ? 1 : n * factorial(n - 1)  // 오류!

// 올바른 예: 루프 사용
factorial(int n) =>
    var result = 1
    if n > 1
        result := 1
        for i = 2 to n
            result *= i
    result

fact5 = factorial(5)

// 10.2 복잡한 중첩 계산 오류
// 오류: 과도한 중첩으로 인한 성능 저하
// 잘못된 패턴:
// complexCalc() =>
//     sum = 0.0
//     for i = 0 to 100
//         for j = 0 to 100
//             for k = 0 to 100  // O(n³) - 매우 느림!
//                 sum += i * j * k
//     sum

// 올바른 패턴: 최적화된 알고리즘
optimizedCalc() =>
    sum = 0.0
    for i = 0 to 100
        sum += i * close  // O(n) - 빠름
    sum

optimizedResult = optimizedCalc()

// 10.3 무한 루프 방지
// 오류: while 무한 루프
safeWhileLoop() =>
    var counter = 0
    var maxIter = 1000  // 안전 장치
    var result = 0.0
    
    while counter < 10 and counter < maxIter
        result += counter
        counter += 1
        
        // 비정상 종료 조건
        if result > 1000000
            break
    result

safeResult = safeWhileLoop()

// ============================================
// PART 11: 시각화 관련 계산 오류
// ============================================

// 11.1 plot 계산 타이밍 오류
// 오류: 조건문 내부에서 plot 호출
// 잘못된 예:
// if close > open
//     plot(close)  // 오류! plot은 최상위에서만

// 올바른 예: 조건부 값 계산 후 plot
plotValue1 = close > open ? close : na
plot(plotValue1, "조건부 플롯", color.green)

// 11.2 plotshape 위치 계산 오류
// 오류: 잘못된 위치 값
shapeCondition = ta.crossover(close, ta.sma(close, 20))

// 올바른 위치 지정:
plotshape(shapeCondition, "매수", shape.triangleup, 
     location.belowbar, color.green, size=size.small)

// 11.3 label 텍스트 계산 오류
if barstate.islast and buyCount > 0
    var label infoLabel = label.new(bar_index, high, "", 
         style=label.style_label_down, color=color.blue)
    
    // 올바른 텍스트 계산:
    labelText = "매수: " + str.tostring(buyCount) + 
         "\n매도: " + str.tostring(sellCount) + 
         "\n총이익: " + str.tostring(totalProfit, format.mintick)
    
    label.set_xy(infoLabel, bar_index, high)
    label.set_text(infoLabel, labelText)

// ============================================
// PART 12: 타입 변환 계산 오류
// ============================================

// 12.1 명시적 타입 변환 누락
intVal = 10
floatVal = 3.14

// 잘못된 예:
// mixed = intVal + floatVal  // 자동 변환되지만 명시적이 좋음

// 올바른 예:
mixedCalc = float(intVal) + floatVal

// 12.2 문자열 변환 포맷 오류
priceValue = 1234.56789

// 기본 변환:
str1 = str.tostring(priceValue)  // "1234.56789"

// 포맷 지정:
str2 = str.tostring(priceValue, format.mintick)  // 틱 단위
str3 = str.tostring(priceValue, "#.##")  // "1234.57"

// 12.3 bool 변환 오류
// Pine Script는 암시적 bool 변환 없음
numericValue = 1

// 잘못된 예:
// if numericValue  // 오류! 숫자를 bool로 자동 변환 안 됨

// 올바른 예:
if numericValue != 0
    // 실행

// ============================================
// 종합 오류 통계 및 시각화
// ============================================

var int totalErrors = 0
var int calculationErrors = 0
var int tupleErrors = 0
var int arrayErrors = 0

// 런타임 오류 감지
if na(close) or na(open)
    totalErrors += 1

if array.size(prices) > 1000  // 배열 크기 과다
    arrayErrors += 1

// 오류 대시보드
if barstate.islast and showErrorGuide
    var table errorDashboard = table.new(position.top_right, 4, 25, 
         bgcolor=color.new(color.black, 90), 
         border_width=2, border_color=color.blue)
    
    // 헤더
    table.cell(errorDashboard, 0, 0, "카테고리", 
         bgcolor=color.new(color.blue, 60), text_color=color.white)
    table.cell(errorDashboard, 1, 0, "오류 유형", 
         bgcolor=color.new(color.blue, 60), text_color=color.white)
    table.cell(errorDashboard, 2, 0, "증상", 
         bgcolor=color.new(color.blue, 60), text_color=color.white)
    table.cell(errorDashboard, 3, 0, "해결책", 
         bgcolor=color.new(color.blue, 60), text_color=color.white)
    
    // 데이터 행
    row = 1
    
    // IF 계산 오류
    table.cell(errorDashboard, 0, row, "IF 계산", text_color=color.yellow, text_size=size.tiny)
    table.cell(errorDashboard, 1, row, "타입 불일치", text_color=color.white, text_size=size.tiny)
    table.cell(errorDashboard, 2, row, "분기별 다른 타입", text_color=color.orange, text_size=size.tiny)
    table.cell(errorDashboard, 3, row, "모든 분기 같은 타입", text_color=color.lime, text_size=size.tiny)
    row += 1
    
    table.cell(errorDashboard, 0, row, "IF 계산", text_color=color.yellow, text_size=size.tiny)
    table.cell(errorDashboard, 1, row, "else 누락", text_color=color.white, text_size=size.tiny)
    table.cell(errorDashboard, 2, row, "조건 false시 na", text_color=color.orange, text_size=size.tiny)
    table.cell(errorDashboard, 3, row, "else 분기 명시", text_color=color.lime, text_size=size.tiny)
    row += 1
    
    // 튜플 오류
    table.cell(errorDashboard, 0, row, "튜플", text_color=color.yellow, text_size=size.tiny)
    table.cell(errorDashboard, 1, row, "개수 불일치", text_color=color.white, text_size=size.tiny)
    table.cell(errorDashboard, 2, row, "언패킹 오류", text_color=color.orange, text_size=size.tiny)
    table.cell(errorDashboard, 3, row, "개수 일치시킴", text_color=color.lime, text_size=size.tiny)
    row += 1
    
    table.cell(errorDashboard, 0, row, "튜플", text_color=color.yellow, text_size=size.tiny)
    table.cell(errorDashboard, 1, row, "security 튜플", text_color=color.white, text_size=size.tiny)
    table.cell(errorDashboard, 2, row, "직접 배열 불가", text_color=color.orange, text_size=size.tiny)
    table.cell(errorDashboard, 3, row, "함수로 래핑", text_color=color.lime, text_size=size.tiny)
    row += 1
    
    // 함수 오류
    table.cell(errorDashboard, 0, row, "함수", text_color=color.yellow, text_size=size.tiny)
    table.cell(errorDashboard, 1, row, "반환값 오해", text_color=color.white, text_size=size.tiny)
    table.cell(errorDashboard, 2, row, "마지막 값만 반환", text_color=color.orange, text_size=size.tiny)
    table.cell(errorDashboard, 3, row, "튜플 사용", text_color=color.lime, text_size=size.tiny)
    row += 1
    
    // 연산자 오류
    table.cell(errorDashboard, 0, row, "연산자", text_color=color.yellow, text_size=size.tiny)
    table.cell(errorDashboard, 1, row, "0으로 나누기", text_color=color.white, text_size=size.tiny)
    table.cell(errorDashboard, 2, row, "Infinity 반환", text_color=color.orange, text_size=size.tiny)
    table.cell(errorDashboard, 3, row, "0 체크 필수", text_color=color.lime, text_size=size.tiny)
    row += 1
    
    table.cell(errorDashboard, 0, row, "연산자", text_color=color.yellow, text_size=size.tiny)
    table.cell(errorDashboard, 1, row, "float 비교", text_color=color.white, text_size=size.tiny)
    table.cell(errorDashboard, 2, row, "부동소수점 오차", text_color=color.orange, text_size=size.tiny)
    table.cell(errorDashboard, 3, row, "epsilon 범위 비교", text_color=color.lime, text_size=size.tiny)
    row += 1
    
    // 배열 오류
    table.cell(errorDashboard, 0, row, "배열", text_color=color.yellow, text_size=size.tiny)
    table.cell(errorDashboard, 1, row, "범위 초과", text_color=color.white, text_size=size.tiny)
    table.cell(errorDashboard, 2, row, "인덱스 오류", text_color=color.orange, text_size=size.tiny)
    table.cell(errorDashboard, 3, row, "size() 체크", text_color=color.lime, text_size=size.tiny)
    row += 1
    
    table.cell(errorDashboard, 0, row, "배열", text_color=color.yellow, text_size=size.tiny)
    table.cell(errorDashboard, 1, row, "얕은 복사", text_color=color.white, text_size=size.tiny)
    table.cell(errorDashboard, 2, row, "참조 공유", text_color=color.orange, text_size=size.tiny)
    table.cell(errorDashboard, 3, row, "array.copy() 사용", text_color=color.lime, text_size=size.tiny)
    row += 1
    
    // 시계열 오류
    table.cell(errorDashboard, 0, row, "시계열", text_color=color.yellow, text_size=size.tiny)
    table.cell(errorDashboard, 1, row, "첫 바 참조", text_color=color.white, text_size=size.tiny)
    table.cell(errorDashboard, 2, row, "[1] 접근시 na", text_color=color.orange, text_size=size.tiny)
    table.cell(errorDashboard, 3, row, "na() 체크", text_color=color.lime, text_size=size.tiny)
    row += 1
    
    table.cell(errorDashboard, 0, row, "시계열", text_color=color.yellow, text_size=size.tiny)
    table.cell(errorDashboard, 1, row, "함수+[1]", text_color=color.white, text_size=size.tiny)
    table.cell(errorDashboard, 2, row, "직접 적용 불가", text_color=color.orange, text_size=size.tiny)
    table.cell(errorDashboard, 3, row, "변수 할당 후", text_color=color.lime, text_size=size.tiny)
    row += 1
    
    // Map/Matrix 오류
    table.cell(errorDashboard, 0, row, "Map", text_color=color.yellow, text_size=size.tiny)
    table.cell(errorDashboard, 1, row, "키 타입", text_color=color.white, text_size=size.tiny)
    table.cell(errorDashboard, 2, row, "string만 가능", text_color=color.orange, text_size=size.tiny)
    table.cell(errorDashboard, 3, row, "str.tostring()", text_color=color.lime, text_size=size.tiny)
    row += 1
    
    table.cell(errorDashboard, 0, row, "Matrix", text_color=color.yellow, text_size=size.tiny)
    table.cell(errorDashboard, 1, row, "차원 불일치", text_color=color.white, text_size=size.tiny)
    table.cell(errorDashboard, 2, row, "곱셈 불가", text_color=color.orange, text_size=size.tiny)
    table.cell(errorDashboard, 3, row, "차원 확인", text_color=color.lime, text_size=size.tiny)
    row += 1
    
    // 재귀/성능 오류
    table.cell(errorDashboard, 0, row, "재귀", text_color=color.yellow, text_size=size.tiny)
    table.cell(errorDashboard, 1, row, "재귀 불가", text_color=color.white, text_size=size.tiny)
    table.cell(errorDashboard, 2, row, "미지원", text_color=color.orange, text_size=size.tiny)
    table.cell(errorDashboard, 3, row, "루프 사용", text_color=color.lime, text_size=size.tiny)
    row += 1

// 계산 예제 통계
if barstate.islast and showCalculationErrors
    var table calcStats = table.new(position.bottom_left, 2, 10, 
         bgcolor=color.new(color.navy, 85), 
         border_width=1, border_color=color.aqua)
    
    table.cell(calcStats, 0, 0, "계산 항목", 
         bgcolor=color.new(color.navy, 60), text_color=color.white, text_size=size.small)
    table.cell(calcStats, 1, 0, "현재 값", 
         bgcolor=color.new(color.navy, 60), text_color=color.white, text_size=size.small)
    
    table.cell(calcStats, 0, 1, "IF 결과", text_color=color.white, text_size=size.tiny)
    table.cell(calcStats, 1, 1, str.tostring(correctIf1), text_color=color.aqua, text_size=size.tiny)
    
    table.cell(calcStats, 0, 2, "Switch 결과", text_color=color.white, text_size=size.tiny)
    table.cell(calcStats, 1, 2, str.tostring(betterNested), text_color=color.aqua, text_size=size.tiny)
    
    table.cell(calcStats, 0, 3, "튜플 MA20", text_color=color.white, text_size=size.tiny)
    table.cell(calcStats, 1, 3, str.tostring(ma20, format.mintick), text_color=color.aqua, text_size=size.tiny)
    
    table.cell(calcStats, 0, 4, "튜플 MA50", text_color=color.white, text_size=size.tiny)
    table.cell(calcStats, 1, 4, str.tostring(ma50, format.mintick), text_color=color.aqua, text_size=size.tiny)
    
    table.cell(calcStats, 0, 5, "안전 나눗셈", text_color=color.white, text_size=size.tiny)
    table.cell(calcStats, 1, 5, str.tostring(safeDivision, "#.####"), text_color=color.aqua, text_size=size.tiny)
    
    table.cell(calcStats, 0, 6, "매수 횟수", text_color=color.white, text_size=size.tiny)
    table.cell(calcStats, 1, 6, str.tostring(buyCount), text_color=color.lime, text_size=size.tiny)
    
    table.cell(calcStats, 0, 7, "매도 횟수", text_color=color.white, text_size=size.tiny)
    table.cell(calcStats, 1, 7, str.tostring(sellCount), text_color=color.red, text_size=size.tiny)
    
    table.cell(calcStats, 0, 8, "총 이익", text_color=color.white, text_size=size.tiny)
    table.cell(calcStats, 1, 8, str.tostring(totalProfit, format.mintick), 
         text_color=totalProfit > 0 ? color.lime : color.red, text_size=size.tiny)
    
    table.cell(calcStats, 0, 9, "배열 크기", text_color=color.white, text_size=size.tiny)
    table.cell(calcStats, 1, 9, str.tostring(array.size(prices)), text_color=color.aqua, text_size=size.tiny)

// ============================================
// PART 13: 고급 오류 - 성능 최적화
// ============================================

// 13.1 불필요한 계산 반복 오류
// 잘못된 예: 매 바마다 같은 계산 반복
// slowCalc = ta.sma(close, 200) + ta.ema(close, 100) + ta.rsi(close, 14)

// 올바른 예: 변수에 저장하여 재사용
sma200 = ta.sma(close, 200)
ema100 = ta.ema(close, 100)
rsi14 = ta.rsi(close, 14)
fastCalc = sma200 + ema100 + rsi14

// 13.2 과도한 보안 함수 호출
// 잘못된 패턴: 여러 번 호출
// htf1 = request.security(syminfo.tickerid, "D", close)
// htf2 = request.security(syminfo.tickerid, "D", open)
// htf3 = request.security(syminfo.tickerid, "D", high)

// 올바른 패턴: 한 번에 튜플로
getHTFData() =>
    [close, open, high, low]

[htfC, htfO, htfH, htfL] = request.security(syminfo.tickerid, "D", getHTFData())

// 13.3 과도한 plot 호출
// 최대 64개 plot만 가능
// 필요한 것만 선택적으로 plot

plot(sma200, "SMA 200", color.blue, 2)
plot(ema100, "EMA 100", color.red, 2)

// ============================================
// PART 14: 고급 오류 - 리페인팅
// ============================================

// 14.1 보안 함수 리페인팅 오류
// 잘못된 예: 리페인팅 발생
// repaintingData = request.security(syminfo.tickerid, "D", close)

// 올바른 예: 리페인팅 방지
nonRepaintingData = request.security(syminfo.tickerid, "D", close[1], 
     barmerge.gaps_off, barmerge.lookahead_on)

// 14.2 변수 타이밍 오류
// varip는 실시간에서만 유지됨
varip int realtimeCounter = 0
var int persistentCounter = 0

if barstate.isrealtime
    realtimeCounter += 1  // 실시간에서만 증가
persistentCounter += 1  // 항상 증가

// ============================================
// PART 15: 고급 오류 - 메모리 관리
// ============================================

// 15.1 배열 메모리 누수
// 잘못된 패턴: 배열이 계속 커짐
// var hugeArray = array.new_float(0)
// array.push(hugeArray, close)  // 무한정 증가

// 올바른 패턴: 크기 제한
var limitedArray = array.new_float(0)
array.push(limitedArray, close)
if array.size(limitedArray) > 500
    array.shift(limitedArray)  // 오래된 것 제거

// 15.2 레이블/라인 누적 오류
// 잘못된 패턴: 매 바마다 새 레이블 생성
// if close > open
//     label.new(bar_index, high, "Buy")  // 메모리 누적

// 올바른 패턴: 기존 것 삭제
var label dynamicLabel = na
if close > open and barstate.isconfirmed
    if not na(dynamicLabel)
        label.delete(dynamicLabel)
    dynamicLabel := label.new(bar_index, high, "Buy", 
         color=color.green, style=label.style_label_down)

// ============================================
// PART 16: 고급 오류 - 데이터 무결성
// ============================================

// 16.1 NA 전파 오류
// NA 값이 계산 전체를 무효화
value1 = close[1]  // 첫 바에서 na
value2 = 10.0

// 잘못된 계산:
// result = value1 + value2  // na + 10 = na

// 올바른 계산: na 처리
cleanValue1 = na(value1) ? close : value1
safeResult = cleanValue1 + value2

// 16.2 무한대/NaN 처리 오류
testDivisor = high - low
calculation = close / testDivisor

// 무한대 체크
isInfinite = not na(calculation) and (calculation == 1.0/0.0 or calculation == -1.0/0.0)

finalValue = isInfinite or na(calculation) ? 0.0 : calculation

// ============================================
// PART 17: 고급 오류 - 타입 시스템
// ============================================

// 17.1 const 한정자 오류
// const는 컴파일 타임 상수
const int MAX_BARS = 500
const float THRESHOLD = 0.618

// 잘못된 사용:
// const float dynamicValue = close  // 오류! const는 상수만

// 올바른 사용:
const string INDICATOR_NAME = "My Indicator"

// 17.2 input 타입 제약
// input은 simple 타입만 가능
lengthInput = input.int(14, "기간", minval=1, maxval=500)

// 잘못된 사용:
// periodicLength = lengthInput + bar_index  // series가 됨
// smaWrong = ta.sma(close, periodicLength)  // 오류!

// 올바른 사용:
smaCorrect = ta.sma(close, lengthInput)  // lengthInput은 simple

// ============================================
// PART 18: 고급 오류 - 문자열 처리
// ============================================

// 18.1 문자열 연결 성능
// 잘못된 패턴: 루프에서 문자열 연결
// longString = ""
// for i = 0 to 100
//     longString := longString + str.tostring(i)  // 느림

// 올바른 패턴: 배열 사용
var strArray = array.new_string(0)
if bar_index < 100
    array.push(strArray, str.tostring(bar_index))

// 18.2 문자열 비교 오류
str1 = "AAPL"
str2 = "aapl"

// 대소문자 구분됨
caseSensitive = str1 == str2  // false

// 대소문자 무시 비교 (직접 구현 필요)
lowerStr1 = str.lower(str1)
lowerStr2 = str.lower(str2)
caseInsensitive = lowerStr1 == lowerStr2  // true

// ============================================
// PART 19: 고급 오류 - 전략 특화
// ============================================

// 19.1 strategy.entry 타이밍 오류
// strategy에서만 사용 가능 (indicator에서는 불가)

// 19.2 포지션 관리 오류
// var로 포지션 추적 시 주의
var float avgEntryPrice = 0.0
var int positionSize = 0

// 올바른 포지션 추적
if buySignal
    avgEntryPrice := close
    positionSize := 1

if sellSignal
    positionSize := 0

// ============================================
// PART 20: 고급 오류 - 다중 타임프레임
// ============================================

// 20.1 타임프레임 비교 오류
currentTF = timeframe.period
higherTF = timeframe.in_seconds(currentTF) * 4

// 20.2 타임프레임 혼합 계산
// 서로 다른 타임프레임 데이터 직접 연산 주의
dailyClose = request.security(syminfo.tickerid, "D", close, barmerge.gaps_off)
hourlyClose = request.security(syminfo.tickerid, "60", close, barmerge.gaps_off)

// 올바른 비교: 같은 시간 기준으로
dailyVsHourly = dailyClose > hourlyClose

// 고급 통계 테이블
if barstate.islast and showAdvancedErrors
    var table advTable = table.new(position.middle_right, 2, 12, 
         bgcolor=color.new(color.maroon, 85), 
         border_width=1, border_color=color.orange)
    
    table.cell(advTable, 0, 0, "고급 검사", 
         bgcolor=color.new(color.maroon, 60), text_color=color.white, text_size=size.small)
    table.cell(advTable, 1, 0, "상태", 
         bgcolor=color.new(color.maroon, 60), text_color=color.white, text_size=size.small)
    
    table.cell(advTable, 0, 1, "배열 크기", text_color=color.white, text_size=size.tiny)
    arrayStatus = array.size(limitedArray) < 500 ? "✓ 정상" : "⚠ 초과"
    table.cell(advTable, 1, 1, arrayStatus, 
         text_color=array.size(limitedArray) < 500 ? color.lime : color.red, text_size=size.tiny)
    
    table.cell(advTable, 0, 2, "NA 값", text_color=color.white, text_size=size.tiny)
    naStatus = na(close) ? "✗ 오류" : "✓ 정상"
    table.cell(advTable, 1, 2, naStatus, 
         text_color=na(close) ? color.red : color.lime, text_size=size.tiny)
    
    table.cell(advTable, 0, 3, "무한대", text_color=color.white, text_size=size.tiny)
    infStatus = isInfinite ? "✗ 감지" : "✓ 정상"
    table.cell(advTable, 1, 3, infStatus, 
         text_color=isInfinite ? color.red : color.lime, text_size=size.tiny)
    
    table.cell(advTable, 0, 4, "0 나눗셈", text_color=color.white, text_size=size.tiny)
    divStatus = divisor != 0 ? "✓ 안전" : "⚠ 주의"
    table.cell(advTable, 1, 4, divStatus, 
         text_color=divisor != 0 ? color.lime : color.yellow, text_size=size.tiny)
    
    table.cell(advTable, 0, 5, "리페인팅", text_color=color.white, text_size=size.tiny)
    table.cell(advTable, 1, 5, "✓ 방지됨", text_color=color.lime, text_size=size.tiny)
    
    table.cell(advTable, 0, 6, "메모리", text_color=color.white, text_size=size.tiny)
    table.cell(advTable, 1, 6, "✓ 최적화", text_color=color.lime, text_size=size.tiny)
    
    table.cell(advTable, 0, 7, "계산 효율", text_color=color.white, text_size=size.tiny)
    table.cell(advTable, 1, 7, "✓ 양호", text_color=color.lime, text_size=size.tiny)
    
    table.cell(advTable, 0, 8, "타입 안전", text_color=color.white, text_size=size.tiny)
    table.cell(advTable, 1, 8, "✓ 확인됨", text_color=color.lime, text_size=size.tiny)
    
    table.cell(advTable, 0, 9, "Persistent", text_color=color.white, text_size=size.tiny)
    table.cell(advTable, 1, 9, str.tostring(persistentCounter), text_color=color.aqua, text_size=size.tiny)
    
    table.cell(advTable, 0, 10, "HTF 데이터", text_color=color.white, text_size=size.tiny)
    htfStatus = not na(htfC) ? "✓ 로드됨" : "✗ 오류"
    table.cell(advTable, 1, 10, htfStatus, 
         text_color=not na(htfC) ? color.lime : color.red, text_size=size.tiny)
    
    table.cell(advTable, 0, 11, "총 오류", text_color=color.white, text_size=size.tiny)
    table.cell(advTable, 1, 11, str.tostring(totalErrors), 
         text_color=totalErrors == 0 ? color.lime : color.red, text_size=size.tiny)

// ============================================
// PART 21: 계산 로직 오류 (매우 중요!)
// ============================================

// 21.1 누적 계산 오류
// 오류: var 없이 누적 시도
// 잘못된 예:
// total = 0
// total = total + close  // 매 바마다 close로 초기화됨!

// 올바른 예: var 사용
var float correctTotal = 0
correctTotal += close  // 제대로 누적됨

// 21.2 조건 카운팅 로직 오류
// 오류: 조건 중복 카운팅
var int upDays = 0
var int downDays = 0

// 잘못된 로직:
// if close > open
//     upDays = upDays + 1
// if close > close[1]  // 두 조건이 동시에 true일 수 있음
//     upDays = upDays + 1  // 중복 카운팅!

// 올바른 로직: 명확한 분기
if close > open and not na(close[1])
    if close > close[1]
        upDays += 1
    else
        // 상승캔들이지만 전일대비 하락
        upDays += 1
else if close < open
    downDays += 1

// 21.3 연속 카운팅 오류
// 오류: 연속 조건 추적 실패
var int consecutiveUp = 0

// 잘못된 로직:
// if close > open
//     consecutiveUp = consecutiveUp + 1  // 리셋 로직 없음

// 올바른 로직: 조건 깨지면 리셋
if close > open
    consecutiveUp += 1
else
    consecutiveUp := 0  // 조건 안맞으면 0으로 리셋

// 21.4 최대/최소값 추적 오류
var float highestHigh = 0.0
var float lowestLow = 999999.9

// 잘못된 로직: 초기값 문제
// if high > highestHigh
//     highestHigh = high  // 첫 바에서 0보다 작으면?

// 올바른 로직: 적절한 초기화
if bar_index == 0
    highestHigh := high
    lowestLow := low
else
    if high > highestHigh
        highestHigh := high
    if low < lowestLow
        lowestLow := low

// 21.5 평균 계산 오류
var float priceSum = 0.0
var int priceCount = 0

// 잘못된 로직: 0으로 나누기
// avgPrice = priceSum / priceCount  // priceCount가 0이면?

// 올바른 로직:
priceSum += close
priceCount += 1
avgPrice = priceCount > 0 ? priceSum / priceCount : close

// 21.6 백분율 계산 오류
// 오류: 기준값 검증 없음
basePrice = close[1]

// 잘못된 계산:
// percentChange = (close - basePrice) / basePrice * 100  // basePrice가 0이면?

// 올바른 계산:
validBase = not na(basePrice) and basePrice != 0
percentChange = validBase ? (close - basePrice) / basePrice * 100 : 0

// 21.7 조건 결합 로직 오류
// 오류: 논리 연산자 오용
ma50Calc = ta.sma(close, 50)
ma200Calc = ta.sma(close, 200)

// 잘못된 로직:
// goldenCross = ma50Calc > ma200Calc and ma50Calc[1] < ma200Calc[1]
// 문제: 첫 바에서 [1] 참조 시 na

// 올바른 로직: na 체크
validCross = not na(ma50Calc) and not na(ma200Calc) and 
     not na(ma50Calc[1]) and not na(ma200Calc[1])
goldenCross = validCross and ma50Calc > ma200Calc and ma50Calc[1] <= ma200Calc[1]

// 21.8 타임프레임 의존 계산 오류
// 오류: 타임프레임에 따라 결과가 달라지는 로직
// 잘못된 예:
// signal = bar_index % 10 == 0  // 5분봉과 1시간봉에서 다른 결과

// 올바른 예: 시간 기반
isNewDay = ta.change(dayofmonth) != 0
isNewWeek = ta.change(weekofyear) != 0

// 21.9 신호 지연 오류
// 오류: 신호가 한 바 늦게 발생
rsiValue = ta.rsi(close, 14)

// 잘못된 신호:
// buySignalDelayed = rsiValue[1] < 30 and rsiValue > 30  // 한 바 늦음

// 올바른 신호: 즉시 감지
buySignalImmediate = rsiValue < 30 and rsiValue[1] >= 30

// 21.10 필터 로직 오류
volumeMA = ta.sma(volume, 20)

// 잘못된 필터:
// filtered = close > open and volume > volumeMA and rsiValue > 50
// 문제: 모든 조건이 동시에 만족되기 어려움

// 올바른 필터: 우선순위 설정
primaryCondition = close > open
secondaryCondition = volume > volumeMA
tertiaryCondition = rsiValue > 50
strongSignal = primaryCondition and secondaryCondition and tertiaryCondition
weakSignal = primaryCondition and (secondaryCondition or tertiaryCondition)

// ============================================
// PART 22: 캔들/레이블 고정 오류 (중요!)
// ============================================

// 22.1 레이블이 움직이는 오류
// 오류: barstate 체크 없이 레이블 생성
// 잘못된 예:
// if close > open
//     label.new(bar_index, high, "UP")  // 매 틱마다 새 레이블!

// 올바른 예 1: 확정된 바에서만 생성
if close > open and barstate.isconfirmed
    label.new(bar_index, high, "UP", 
         style=label.style_label_down, 
         color=color.green,
         textcolor=color.white)

// 올바른 예 2: 마지막 바 제외
if close > open and not barstate.islast
    label.new(bar_index, high, "UP", 
         style=label.style_label_down, 
         color=color.green,
         textcolor=color.white)

// 22.2 레이블 위치가 변경되는 오류
// 오류: 변수에 저장 후 위치 계속 업데이트
var label myLabel = na

// 잘못된 패턴:
// if not na(myLabel)
//     label.set_xy(myLabel, bar_index, high)  // 매 바마다 위치 변경!

// 올바른 패턴 1: 한 번만 생성
if na(myLabel) and close > ta.sma(close, 50)
    myLabel := label.new(bar_index, high, "Signal", 
         color=color.blue)
// 위치 업데이트 안함 - 고정됨

// 올바른 패턴 2: 조건부 업데이트
var label dynamicLabel2 = na
var bool labelLocked = false

if barstate.isrealtime and not labelLocked
    if not na(dynamicLabel2)
        label.delete(dynamicLabel2)
    dynamicLabel2 := label.new(bar_index, high, "Live", 
         color=color.orange)

if barstate.isconfirmed
    labelLocked := true  // 바 확정 후 고정

// 22.3 plotshape 리페인팅 오류
// 오류: 조건이 계속 변경됨
emaFast = ta.ema(close, 12)
emaSlow = ta.ema(close, 26)

// 잘못된 사용:
// crossOver = emaFast > emaSlow  // 매 틱마다 변할 수 있음
// plotshape(crossOver, style=shape.triangleup, location=location.belowbar)

// 올바른 사용: crossover 함수 사용
confirmedCrossOver = ta.crossover(emaFast, emaSlow)
plotshape(confirmedCrossOver and barstate.isconfirmed, 
     "EMA Cross", shape.triangleup, location.belowbar, 
     color.green, size=size.small)

// 22.4 라인이 움직이는 오류
var line trendLine = na
var float lineStartPrice = na
var int lineStartBar = na

// 잘못된 패턴:
// if someCondition
//     line.new(bar_index-10, low[10], bar_index, high)  // 끝점이 계속 변함

// 올바른 패턴: 시작점 고정
if someCondition and barstate.isconfirmed and na(trendLine)
    lineStartBar := bar_index - 10
    lineStartPrice := low[10]
    trendLine := line.new(lineStartBar, lineStartPrice, 
         bar_index, high, 
         color=color.blue, width=2)

// 22.5 박스가 확장되는 오류
var box supportBox = na
var float boxTop = na
var float boxBottom = na

// 잘못된 패턴:
// if condition
//     box.new(bar_index-20, high[20], bar_index, low[20])  // 끝점이 현재 바

// 올바른 패턴: 끝점 고정
if condition and barstate.isconfirmed
    boxTop := high[20]
    boxBottom := low[20]
    supportBox := box.new(bar_index-20, boxTop, bar_index-10, boxBottom,
         border_color=color.blue, bgcolor=color.new(color.blue, 90))

// 22.6 텍스트 내용이 변경되는 오류
var label infoLabel = na
var string fixedText = ""

// 잘못된 패턴:
// if barstate.islast
//     label.set_text(infoLabel, "Price: " + str.tostring(close))  // 계속 변함

// 올바른 패턴: 확정 후 고정
if barstate.isconfirmed and someCondition
    fixedText := "Price: " + str.tostring(close, format.mintick)
    if not na(infoLabel)
        label.delete(infoLabel)
    infoLabel := label.new(bar_index, high, fixedText, 
         color=color.blue, textcolor=color.white)

// 22.7 alertcondition 리페인팅 오류
// 오류: 조건이 실시간에서 바뀜
// 잘못된 조건:
// unstableCondition = close > ta.highest(high, 20)  // 계속 변할 수 있음

// 올바른 조건: 확정 체크
stableHighest = ta.highest(high[1], 20)  // [1]로 확정된 값 사용
stableCondition = close > stableHighest and barstate.isconfirmed

alertcondition(stableCondition, "안정적 신호", "가격이 최고점 돌파")

// ============================================
// PART 23: 구현 방식 오류
// ============================================

// 23.1 전역 변수 남용 오류
// 잘못된 구조:
// var global1 = 0
// var global2 = 0
// var global3 = 0
// ... (수십 개의 전역 변수)

// 올바른 구조: 배열이나 함수로 캡슐화
var array<float> metrics = array.from(0.0, 0.0, 0.0, 0.0, 0.0)

updateMetric(int index, float value) =>
    if index >= 0 and index < array.size(metrics)
        array.set(metrics, index, value)

getMetric(int index) =>
    index >= 0 and index < array.size(metrics) ? 
         array.get(metrics, index) : 0.0

// 23.2 중복 코드 오류
// 잘못된 패턴:
// sma20Close = ta.sma(close, 20)
// sma20Open = ta.sma(open, 20)
// sma20High = ta.sma(high, 20)
// sma20Low = ta.sma(low, 20)

// 올바른 패턴: 함수 재사용
calcSMA(series float src, simple int len) =>
    ta.sma(src, len)

sma20C = calcSMA(close, 20)
sma20O = calcSMA(open, 20)
sma20H = calcSMA(high, 20)
sma20L = calcSMA(low, 20)

// 23.3 하드코딩 오류
// 잘못된 방식:
// if close > 50000 and volume > 1000000  // 특정 자산에만 작동

// 올바른 방식: 상대적 값 사용
atr20 = ta.atr(20)
priceThreshold = close > ta.sma(close, 200)
volumeThreshold = volume > ta.sma(volume, 20) * 1.5

validSignal = priceThreshold and volumeThreshold

// 23.4 매직 넘버 오류
// 잘못된 코드:
// result = close * 0.382 + high * 0.618 - low * 0.236

// 올바른 코드: 상수 정의
const float FIBO_382 = 0.382
const float FIBO_618 = 0.618
const float FIBO_236 = 0.236

fiboResult = close * FIBO_382 + high * FIBO_618 - low * FIBO_236

// 23.5 과도한 계산 중첩
// 잘못된 패턴:
// complex = ta.sma(ta.ema(ta.rsi(ta.stoch(close, high, low, 14), 14, 3, 3), 9), 20)

// 올바른 패턴: 단계별 계산
stochValue = ta.stoch(close, high, low, 14)
rsiOfStoch = ta.rsi(stochValue, 14)
emaOfRsi = ta.ema(rsiOfStoch, 9)
smaFinal = ta.sma(emaOfRsi, 20)

// 23.6 조건문 중복 검사
// 잘못된 로직:
// if close > open
//     if close > open  // 중복!
//         if volume > 0
//             // 실행

// 올바른 로직:
cond1 = close > open
cond2 = volume > 0

if cond1 and cond2
    // 실행

// 23.7 불필요한 변수 할당
// 잘못된 패턴:
// temp1 = close
// temp2 = temp1
// temp3 = temp2
// finalValue = temp3

// 올바른 패턴:
finalValue2 = close  // 직접 사용

// 23.8 함수 반환값 무시
// 잘못된 사용:
// ta.sma(close, 20)  // 계산만 하고 사용 안함 (낭비)

// 올바른 사용:
smaUsed = ta.sma(close, 20)
plot(smaUsed, "SMA", color.blue)

// 23.9 플래그 변수 오용
var bool setupComplete = false

// 잘못된 패턴:
// if not setupComplete
//     setupComplete = true  // := 사용해야 함
//     // 초기화 코드

// 올바른 패턴:
if not setupComplete
    setupComplete := true
    // 초기화 코드 (한 번만 실행됨)

// 23.10 순환 참조 오류
// 잘못된 코드 (불가능):
// value1 = value2 + 10
// value2 = value1 - 5  // 순환 참조!

// 올바른 코드:
baseValue = close
derivedValue1 = baseValue + 10
derivedValue2 = baseValue - 5

// ============================================
// PART 24: 차트 스케일 문제
// ============================================

// 24.1 Y축 스케일 오류
// 오류: 값의 범위가 너무 다름
// 잘못된 예: RSI(0-100)와 가격(수천~수만)을 같이 plot

// 올바른 예: 정규화
normalizedPrice = (close - ta.lowest(close, 100)) / 
     (ta.highest(close, 100) - ta.lowest(close, 100)) * 100

plot(rsiValue, "RSI", color.purple)
plot(normalizedPrice, "Price Norm", color.blue)

// 24.2 라인 그래프 오버레이 오류
// overlay=true일 때 가격과 무관한 지표 plot 시 문제

// 해결책: 별도 pane 사용하거나 조건부 표시
// indicator("Name", overlay=false)  // 별도 창

// 24.3 레이블 겹침 오류
var int labelCount = 0
const int MAX_LABELS = 50

createSafeLabel(int idx, float price, string txt, color col) =>
    if labelCount < MAX_LABELS
        labelCount += 1
        label.new(idx, price, txt, color=col, 
             style=label.style_label_down, textcolor=color.white,
             size=size.small)

if buySignalImmediate and barstate.isconfirmed
    createSafeLabel(bar_index, low, "B", color.green)

// ============================================
// 실전 예제: 올바른 구현
// ============================================

// 완전한 시그널 시스템 (리페인팅 없음)
var int confirmedBuyCount = 0
var int confirmedSellCount = 0
var label lastSignalLabel = na

// 시그널 조건 (확정된 데이터만 사용)
maShort = ta.sma(close, 20)
maLong = ta.sma(close, 50)
rsi14 = ta.rsi(close, 14)
volume20 = ta.sma(volume, 20)

// 신호 로직
buyCondition = ta.crossover(maShort, maLong) and 
     rsi14 < 70 and 
     volume > volume20 and
     barstate.isconfirmed

sellCondition = ta.crossunder(maShort, maLong) and 
     rsi14 > 30 and
     volume > volume20 and
     barstate.isconfirmed

// 신호 실행 (고정됨)
if buyCondition
    confirmedBuyCount += 1
    if not na(lastSignalLabel)
        label.delete(lastSignalLabel)
    lastSignalLabel := label.new(bar_index, low * 0.999, 
         "BUY #" + str.tostring(confirmedBuyCount), 
         color=color.green, 
         style=label.style_label_up,
         textcolor=color.white,
         size=size.normal)

if sellCondition
    confirmedSellCount += 1
    if not na(lastSignalLabel)
        label.delete(lastSignalLabel)
    lastSignalLabel := label.new(bar_index, high * 1.001, 
         "SELL #" + str.tostring(confirmedSellCount), 
         color=color.red, 
         style=label.style_label_down,
         textcolor=color.white,
         size=size.normal)

// 확정된 신호만 표시
plotshape(buyCondition, "매수", shape.triangleup, 
     location.belowbar, color.green, size=size.small)
plotshape(sellCondition, "매도", shape.triangledown, 
     location.abovebar, color.red, size=size.small)

// 통계 대시보드 업데이트
if barstate.islast
    var table implementationTable = table.new(position.bottom_right, 2, 15, 
         bgcolor=color.new(color.teal, 85), 
         border_width=1, border_color=color.yellow)
    
    table.cell(implementationTable, 0, 0, "구현 체크", 
         bgcolor=color.new(color.teal, 60), text_color=color.white)
    table.cell(implementationTable, 1, 0, "상태", 
         bgcolor=color.new(color.teal, 60), text_color=color.white)
    
    table.cell(implementationTable, 0, 1, "레이블 고정", text_color=color.white, text_size=size.tiny)
    table.cell(implementationTable, 1, 1, "✓ 확인됨", text_color=color.lime, text_size=size.tiny)
    
    table.cell(implementationTable, 0, 2, "리페인팅", text_color=color.white, text_size=size.tiny)
    table.cell(implementationTable, 1, 2, "✓ 방지됨", text_color=color.lime, text_size=size.tiny)
    
    table.cell(implementationTable, 0, 3, "barstate 사용", text_color=color.white, text_size=size.tiny)
    table.cell(implementationTable, 1, 3, "✓ 적용됨", text_color=color.lime, text_size=size.tiny)
    
    table.cell(implementationTable, 0, 4, "누적 계산", text_color=color.white, text_size=size.tiny)
    table.cell(implementationTable, 1, 4, "✓ 정확함", text_color=color.lime, text_size=size.tiny)
    
    table.cell(implementationTable, 0, 5, "0 나눗셈", text_color=color.white, text_size=size.tiny)
    table.cell(implementationTable, 1, 5, "✓ 검증됨", text_color=color.lime, text_size=size.tiny)
    
    table.cell(implementationTable, 0, 6, "NA 처리", text_color=color.white, text_size=size.tiny)
    table.cell(implementationTable, 1, 6, "✓ 안전함", text_color=color.lime, text_size=size.tiny)
    
    table.cell(implementationTable, 0, 7, "함수 캡슐화", text_color=color.white, text_size=size.tiny)
    table.cell(implementationTable, 1, 7, "✓ 적용됨", text_color=color.lime, text_size=size.tiny)
    
    table.cell(implementationTable, 0, 8, "하드코딩", text_color=color.white, text_size=size.tiny)
    table.cell(implementationTable, 1, 8, "✓ 제거됨", text_color=color.lime, text_size=size.tiny)
    
    table.cell(implementationTable, 0, 9, "연속 카운팅", text_color=color.white, text_size=size.tiny)
    table.cell(implementationTable, 1, 9, str.tostring(consecutiveUp), text_color=color.aqua, text_size=size.tiny)
    
    table.cell(implementationTable, 0, 10, "확정 매수", text_color=color.white, text_size=size.tiny)
    table.cell(implementationTable, 1, 10, str.tostring(confirmedBuyCount), text_color=color.lime, text_size=size.tiny)
    
    table.cell(implementationTable, 0, 11, "확정 매도", text_color=color.white, text_size=size.tiny)
    table.cell(implementationTable, 1, 11, str.tostring(confirmedSellCount), text_color=color.red, text_size=size.tiny)
    
    table.cell(implementationTable, 0, 12, "최고가", text_color=color.white, text_size=size.tiny)
    table.cell(implementationTable, 1, 12, str.tostring(highestHigh, format.mintick), text_color=color.aqua, text_size=size.tiny)
    
    table.cell(implementationTable, 0, 13, "최저가", text_color=color.white, text_size=size.tiny)
    table.cell(implementationTable, 1, 13, str.tostring(lowestLow, format.mintick), text_color=color.aqua, text_size=size.tiny)
    
    table.cell(implementationTable, 0, 14, "평균가", text_color=color.white, text_size=size.tiny)
    table.cell(implementationTable, 1, 14, str.tostring(avgPrice, format.mintick), text_color=color.aqua, text_size=size.tiny)

// 배경색으로 신호 강조 (확정된 바만)
bgcolor(buyCondition ? color.new(color.green, 95) : 
     sellCondition ? color.new(color.red, 95) : na)

// MA 플롯
plot(maShort, "MA20", color.orange, 2)
plot(maLong, "MA50", color.blue, 2)yellow, text_size=size.tiny)
    table.cell(errorDashboard, 1, row, "series/simple", text_color=color.white, text_size=size.tiny)
    table.cell(errorDashboard, 2, row, "타입 한정자 오류", text_color=color.orange, text_size=size.tiny)
    table.cell(errorDashboard, 3, row, "명시적 타입 지정", text_color=color.lime, text_size=size.tiny)
    row += 1
    
    table.cell(errorDashboard, 0, row, "함수", text_color=color.